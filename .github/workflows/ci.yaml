name: Pulling docker-app image and db in docker

on:
  push:
    branches:
      - main
      - dev
  pull_request:
    branches:
      - main
      - dev
  workflow_dispatch:

jobs:
  build:
    runs-on: self-hosted
    steps:
      - name: Checkouting
        uses: actions/checkout@v4.3.1

      - name: Create .env file from secrets
        run: |
          cd lab2
          # Создаем .env файл из секретов GitHub Actions
          # Если DATABASE_URL задан полностью, используем его
          # Иначе собираем из отдельных компонентов
          if [ -n "${{ secrets.DATABASE_URL }}" ]; then
            echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" > .env
          else
            # Собираем DATABASE_URL из отдельных секретов
            POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
            POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
            POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
            POSTGRES_HOST="${{ secrets.POSTGRES_HOST }}"
            
            echo "DATABASE_URL=postgresql+psycopg2://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:5432/${POSTGRES_DB}" > .env
          fi
          
          # Добавляем FLASK_SECRET
          echo "FLASK_SECRET=${{ secrets.FLASK_SECRET }}" >> .env

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Create virtual environment
        run: |
          cd lab2
          python -m venv venv || python3 -m venv venv
          echo "Virtual environment created in lab2/"

      - name: Activate virtual environment and upgrade pip
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          python -m pip install --upgrade pip

      - name: Install dependencies
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Install pre-commit hooks
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          pre-commit install || echo "Pre-commit install skipped"
          pre-commit --version || echo "Pre-commit not found"

      - name: Run pre-commit
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          pre-commit run --all-files --verbose || true

      - name: Run Flake8 (PEP8)
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics || true

      - name: Run Pylint
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          pylint app.py models.py db_bootstrap.py --fail-under=7.0 || true

      - name: Run Bandit (Security)
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          bandit -r . -f json -o bandit-report.json || true
          bandit -r . -ll || true

      - name: Run Safety (Dependencies Security)
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          safety check --json || true
          safety check || true

      - name: Run MyPy (Type Checking)
        run: |
          cd lab2
          source venv/bin/activate || . venv/bin/activate
          mypy . --ignore-missing-imports || true

      - name: Stop existing containers (if any)
        run: |
          cd lab2
          docker compose down || docker compose down || true
          echo "Existing containers stopped"
      
      - name: Build and start Docker containers
        run: |
          cd lab2
          # Собираем и запускаем контейнеры в фоновом режиме
          docker compose build --no-cache
          docker compose up -d
          

      - name: Wait for database to be ready
        run: |
          cd lab2
          echo "Waiting for PostgreSQL to be ready..."
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            if docker exec postgres pg_isready -U postgres > /dev/null 2>&1; then
              echo "PostgreSQL is ready!"
              break
            fi
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Waiting for PostgreSQL..."
            sleep 2
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "ERROR: PostgreSQL did not become ready in time"
            docker logs postgres
            exit 1
          fi

      - name: Check application container status
        run: |
          cd lab2
          echo "Checking application container status..."
          
          # Проверяем статус контейнера
          if command -v docker-compose &> /dev/null; then
            COMPOSE_CMD="docker-compose"
          else
            COMPOSE_CMD="docker compose"
          fi
          
          # Проверяем, что контейнер запущен
          CONTAINER_STATUS=$(docker ps -a --filter "name=application" --format "{{.Status}}")
          echo "Container status: $CONTAINER_STATUS"
          
          if ! docker ps --filter "name=application" --format "{{.Names}}" | grep -q "application"; then
            echo "ERROR: Application container is not running!"
            echo "Container logs:"
            docker logs application || echo "Cannot get logs"
            echo "Docker compose logs:"
            $COMPOSE_CMD logs myapp || echo "Cannot get compose logs"
            exit 1
          fi
          
          # Проверяем, что процесс Python запущен в контейнере
          if docker exec application ps aux | grep -q "[p]ython.*app.py"; then
            echo "✓ Python process is running in container"
          else
            echo "✗ ERROR: Python process is NOT running in container!"
            echo "Processes in container:"
            docker exec application ps aux || echo "Cannot check processes"
            echo "Container logs:"
            docker logs application --tail 50
            exit 1
          fi
          
          # Проверяем, что порт слушается
          if docker exec application netstat -tuln 2>/dev/null | grep -q ":7009" || \
             docker exec application ss -tuln 2>/dev/null | grep -q ":7009"; then
            echo "✓ Port 7009 is listening in container"
          else
            echo "✗ WARNING: Port 7009 may not be listening"
            echo "Checking network connections:"
            docker exec application netstat -tuln 2>/dev/null || docker exec application ss -tuln 2>/dev/null || echo "Cannot check network"
          fi

      - name: Check application health
        run: |
          cd lab2
          echo "Checking application health endpoint..."
          
          # Проверяем, что приложение отвечает
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            # Пробуем подключиться изнутри контейнера (более надежно)
            if docker exec application curl -f http://localhost:7009/ > /dev/null 2>&1; then
              echo "✓ Application is responding from inside container!"
              break
            fi
            
            # Также пробуем снаружи
            if curl -f http://localhost:7009/ > /dev/null 2>&1; then
              echo "✓ Application is responding from host!"
              break
            fi
            
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Waiting for application..."
            
            # Показываем логи каждые 5 попыток
            if [ $((attempt % 5)) -eq 0 ]; then
              echo "Recent application logs:"
              docker logs application --tail 20
            fi
            
            sleep 2
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "✗ ERROR: Application did not respond after $max_attempts attempts"
            echo "Full application logs:"
            docker logs application
            echo ""
            echo "Docker compose logs:"
            if command -v docker-compose &> /dev/null; then
              docker-compose logs myapp
            else
              docker compose logs myapp
            fi
            echo ""
            echo "Container status:"
            docker ps -a --filter "name=application"
            exit 1
          fi
          
          # Финальная проверка с выводом ответа
          echo "Final health check:"
          curl -v http://localhost:7009/ || docker exec application curl -v http://localhost:7009/

          
      - name: Upload Bandit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bandit-security-report
          path: lab2/bandit-report.json
          if-no-files-found: ignore
